<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>zhang.async documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Zhang</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="10-00-background.html"><div class="inner"><span>Background</span></div></a></li><li class="depth-1 "><a href="10-10-jinterface-concepts.html"><div class="inner"><span> • JInterface Conceptual Components</span></div></a></li><li class="depth-1 "><a href="10-11-motivation-clojure-async.html"><div class="inner"><span> • Motivation for Clojure-native async operations</span></div></a></li><li class="depth-1 "><a href="10-12-motivation-jvm-net.html"><div class="inner"><span> • Motivation for JVM-based network IO</span></div></a></li><li class="depth-1 "><a href="10-13-virtualized-compute.html"><div class="inner"><span> • A World Virtualized Computation</span></div></a></li><li class="depth-1 "><a href="10-20-molecular-inspiration.html"><div class="inner"><span> • Inspiration via Molecular Interactions</span></div></a></li><li class="depth-1 "><a href="10-30-topological-inspiration.html"><div class="inner"><span> • Inspiration via Network Theory</span></div></a></li><li class="depth-1 "><a href="20-00-zhang-design.html"><div class="inner"><span>Zhang Design</span></div></a></li><li class="depth-1 "><a href="30-00-zhang-docs.html"><div class="inner"><span>Documentation</span></div></a></li><li class="depth-1 "><a href="30-10-zhang-getting-started.html"><div class="inner"><span> • Getting Started</span></div></a></li><li class="depth-1 "><a href="30-20-zhang-tutorial.html"><div class="inner"><span> • A Zhang Tutorial</span></div></a></li><li class="depth-1 "><a href="30-30-zhang-applications.html"><div class="inner"><span> • Building Applications with Zhang</span></div></a></li><li class="depth-1 "><a href="30-40-zhang-distributed.html"><div class="inner"><span> • Distributed Zhang</span></div></a></li><li class="depth-1 "><a href="98-resources.html"><div class="inner"><span>Resources</span></div></a></li><li class="depth-1 "><a href="99-other-versions.html"><div class="inner"><span>Zhang API Versions</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>zhang</span></div></div></li><li class="depth-2 branch current"><a href="zhang.async.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>async</span></div></a></li><li class="depth-2"><a href="zhang.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="zhang.async.html#var-admix"><div class="inner"><span>admix</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-buffer"><div class="inner"><span>buffer</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-chan"><div class="inner"><span>chan</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-close.21"><div class="inner"><span>close!</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-cond-select"><div class="inner"><span>cond-select</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-cond-select-blocking"><div class="inner"><span>cond-select-blocking</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-do-select"><div class="inner"><span>do-select</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-dropping-buffer"><div class="inner"><span>dropping-buffer</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-into"><div class="inner"><span>into</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-map"><div class="inner"><span>map</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-merge"><div class="inner"><span>merge</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-mix"><div class="inner"><span>mix</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-mult"><div class="inner"><span>mult</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-offer.21"><div class="inner"><span>offer!</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-onto-chan"><div class="inner"><span>onto-chan</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-pipe"><div class="inner"><span>pipe</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-pipeline"><div class="inner"><span>pipeline</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-pipeline-async"><div class="inner"><span>pipeline-async</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-pipeline-blocking"><div class="inner"><span>pipeline-blocking</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-poll.21"><div class="inner"><span>poll!</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-promise-chan"><div class="inner"><span>promise-chan</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-pub"><div class="inner"><span>pub</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-receive"><div class="inner"><span>receive</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-receive.21"><div class="inner"><span>receive!</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-receive-blocking"><div class="inner"><span>receive-blocking</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-reduce"><div class="inner"><span>reduce</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-select"><div class="inner"><span>select</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-select-blocking"><div class="inner"><span>select-blocking</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-send"><div class="inner"><span>send</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-send.21"><div class="inner"><span>send!</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-send-blocking"><div class="inner"><span>send-blocking</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-sliding-buffer"><div class="inner"><span>sliding-buffer</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-solo-mode"><div class="inner"><span>solo-mode</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-spawn"><div class="inner"><span>spawn</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-spawn-loop"><div class="inner"><span>spawn-loop</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-split"><div class="inner"><span>split</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-sub"><div class="inner"><span>sub</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-take"><div class="inner"><span>take</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-tap"><div class="inner"><span>tap</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-thread"><div class="inner"><span>thread</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-thread-call"><div class="inner"><span>thread-call</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-timeout"><div class="inner"><span>timeout</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-to-chan"><div class="inner"><span>to-chan</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-toggle"><div class="inner"><span>toggle</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-unblocking-buffer.3F"><div class="inner"><span>unblocking-buffer?</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-unique"><div class="inner"><span>unique</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-unmix"><div class="inner"><span>unmix</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-unmix-all"><div class="inner"><span>unmix-all</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-unsub"><div class="inner"><span>unsub</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-unsub-all"><div class="inner"><span>unsub-all</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-untap"><div class="inner"><span>untap</span></div></a></li><li class="depth-1"><a href="zhang.async.html#var-untap-all"><div class="inner"><span>untap-all</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">zhang.async</h1><div class="doc"><div class="markdown"><p>Aliases from <code>core.async</code> for the dyslexic/syntactically challenged.</p>
<p>Mostly this involves replacing:</p>
<ul>
  <li><code>&lt;!</code> variants with <code>receive*</code></li>
  <li><code>&gt;!</code> with <code>send*</code></li>
  <li><code>alt*</code> with <code>select*</code>, and</li>
  <li><code>go*</code> with <code>spawn*</code>.</li>
</ul>
<p>No deprecated functions from <code>core.async</code> are aliased.</p></div></div><div class="public anchor" id="var-admix"><h3>admix</h3><div class="usage"><code>(admix mix ch)</code></div><div class="doc"><div class="markdown"><p>Adds ch as an input to the mix</p></div></div></div><div class="public anchor" id="var-buffer"><h3>buffer</h3><div class="usage"><code>(buffer n)</code></div><div class="doc"><div class="markdown"><p>Returns a fixed buffer of size n. When full, puts will block/park.</p></div></div></div><div class="public anchor" id="var-chan"><h3>chan</h3><div class="usage"><code>(chan)</code><code>(chan buf-or-n)</code><code>(chan buf-or-n xform)</code><code>(chan buf-or-n xform ex-handler)</code></div><div class="doc"><div class="markdown"><p>Creates a channel with an optional buffer, an optional transducer (like (map f), (filter p) etc or a composition thereof), and an optional exception-handler. If buf-or-n is a number, will create and use a fixed buffer of that size. If a transducer is supplied a buffer must be specified. ex-handler must be a fn of one argument - if an exception occurs during transformation it will be called with the Throwable as an argument, and any non-nil return value will be placed in the channel.</p></div></div></div><div class="public anchor" id="var-close.21"><h3>close!</h3><div class="usage"><code>(close! chan)</code></div><div class="doc"><div class="markdown"><p>Closes a channel. The channel will no longer accept any puts (they will be ignored). Data in the channel remains available for taking, until exhausted, after which takes will return nil. If there are any pending takes, they will be dispatched with nil. Closing a closed channel is a no-op. Returns nil.</p>
<p>Logically closing happens after all puts have been delivered. Therefore, any blocked or parked puts will remain blocked/parked until a taker releases them.</p></div></div></div><div class="public anchor" id="var-cond-select"><h3>cond-select</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Alias for <code>core.async/alt!</code> (macro).</p>
<pre><code>(cond-select &amp; clauses)
</code></pre>
<p>Makes a single choice between one of several channel operations, as if by <code>(select ...)</code>, returning the value of the result expr corresponding to the operation completed. Must be called inside a <code>(spawn ...)</code> block.</p></div></div></div><div class="public anchor" id="var-cond-select-blocking"><h3>cond-select-blocking</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Alias for <code>core.async/alt!!</code> (macro).</p>
<pre><code>(cond-select-blocking &amp; clauses)
</code></pre>
<p>Like <code>(cond-select ...)</code>, except as if by <code>(select-blocking ...)</code>. A call will block until completed; not intended for use in <code>(spawn ...)</code> blocks.</p></div></div></div><div class="public anchor" id="var-do-select"><h3>do-select</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Alias for <code>core.async/do-alts</code>.</p>
<pre><code>(do-select fret ports opts)
</code></pre>
<p>Returns derefable <code>[val port]</code> if immediate, <code>nil</code> if enqueued.</p></div></div></div><div class="public anchor" id="var-dropping-buffer"><h3>dropping-buffer</h3><div class="usage"><code>(dropping-buffer n)</code></div><div class="doc"><div class="markdown"><p>Returns a buffer of size n. When full, puts will complete but val will be dropped (no transfer).</p></div></div></div><div class="public anchor" id="var-into"><h3>into</h3><div class="usage"><code>(into coll ch)</code></div><div class="doc"><div class="markdown"><p>Returns a channel containing the single (collection) result of the items taken from the channel conjoined to the supplied collection. ch must close before into produces a result.</p></div></div></div><div class="public anchor" id="var-map"><h3>map</h3><div class="usage"><code>(map f chs)</code><code>(map f chs buf-or-n)</code></div><div class="doc"><div class="markdown"><p>Takes a function and a collection of source channels, and returns a channel which contains the values produced by applying f to the set of first items taken from each source channel, followed by applying f to the set of second items from each channel, until any one of the channels is closed, at which point the output channel will be closed. The returned channel will be unbuffered by default, or a buf-or-n can be supplied</p></div></div></div><div class="public anchor" id="var-merge"><h3>merge</h3><div class="usage"><code>(merge chs)</code><code>(merge chs buf-or-n)</code></div><div class="doc"><div class="markdown"><p>Takes a collection of source channels and returns a channel which contains all values taken from them. The returned channel will be unbuffered by default, or a buf-or-n can be supplied. The channel will close after all the source channels have closed.</p></div></div></div><div class="public anchor" id="var-mix"><h3>mix</h3><div class="usage"><code>(mix out)</code></div><div class="doc"><div class="markdown"><p>Creates and returns a mix of one or more input channels which will be put on the supplied out channel. Input sources can be added to the mix with ‘admix’, and removed with ‘unmix’. A mix supports soloing, muting and pausing multiple inputs atomically using ‘toggle’, and can solo using either muting or pausing as determined by ‘solo-mode’.</p>
<p>Each channel can have zero or more boolean modes set via ‘toggle’:</p>
<p>:solo - when true, only this (ond other soloed) channel(s) will appear  in the mix output channel. :mute and :pause states of soloed  channels are ignored. If solo-mode is :mute, non-soloed  channels are muted, if :pause, non-soloed channels are  paused.</p>
<p>:mute - muted channels will have their contents consumed but not included in the mix :pause - paused channels will not have their contents consumed (and thus also not included in the mix)</p></div></div></div><div class="public anchor" id="var-mult"><h3>mult</h3><div class="usage"><code>(mult ch)</code></div><div class="doc"><div class="markdown"><p>Creates and returns a mult(iple) of the supplied channel. Channels containing copies of the channel can be created with ‘tap’, and detached with ‘untap’.</p>
<p>Each item is distributed to all taps in parallel and synchronously, i.e. each tap must accept before the next item is distributed. Use buffering/windowing to prevent slow taps from holding up the mult.</p>
<p>Items received when there are no taps get dropped.</p>
<p>If a tap puts to a closed channel, it will be removed from the mult.</p></div></div></div><div class="public anchor" id="var-offer.21"><h3>offer!</h3><div class="usage"><code>(offer! port val)</code></div><div class="doc"><div class="markdown"><p>Puts a val into port if it’s possible to do so immediately. nil values are not allowed. Never blocks. Returns true if offer succeeds.</p></div></div></div><div class="public anchor" id="var-onto-chan"><h3>onto-chan</h3><div class="usage"><code>(onto-chan ch coll)</code><code>(onto-chan ch coll close?)</code></div><div class="doc"><div class="markdown"><p>Puts the contents of coll into the supplied channel.</p>
<p>By default the channel will be closed after the items are copied, but can be determined by the close? parameter.</p>
<p>Returns a channel which will close after the items are copied.</p></div></div></div><div class="public anchor" id="var-pipe"><h3>pipe</h3><div class="usage"><code>(pipe from to)</code><code>(pipe from to close?)</code></div><div class="doc"><div class="markdown"><p>Takes elements from the from channel and supplies them to the to channel. By default, the to channel will be closed when the from channel closes, but can be determined by the close? parameter. Will stop consuming the from channel if the to channel closes</p></div></div></div><div class="public anchor" id="var-pipeline"><h3>pipeline</h3><div class="usage"><code>(pipeline n to xf from)</code><code>(pipeline n to xf from close?)</code><code>(pipeline n to xf from close? ex-handler)</code></div><div class="doc"><div class="markdown"><p>Takes elements from the from channel and supplies them to the to channel, subject to the transducer xf, with parallelism n. Because it is parallel, the transducer will be applied independently to each element, not across elements, and may produce zero or more outputs per input. Outputs will be returned in order relative to the inputs. By default, the to channel will be closed when the from channel closes, but can be determined by the close? parameter. Will stop consuming the from channel if the to channel closes. Note this should be used for computational parallelism. If you have multiple blocking operations to put in flight, use pipeline-blocking instead, If you have multiple asynchronous operations to put in flight, use pipeline-async instead.</p></div></div></div><div class="public anchor" id="var-pipeline-async"><h3>pipeline-async</h3><div class="usage"><code>(pipeline-async n to af from)</code><code>(pipeline-async n to af from close?)</code></div><div class="doc"><div class="markdown"><p>Takes elements from the from channel and supplies them to the to channel, subject to the async function af, with parallelism n. af must be a function of two arguments, the first an input value and the second a channel on which to place the result(s). af must close! the channel before returning. The presumption is that af will return immediately, having launched some asynchronous operation (i.e. in another thread) whose completion/callback will manipulate the result channel. Outputs will be returned in order relative to the inputs. By default, the to channel will be closed when the from channel closes, but can be determined by the close? parameter. Will stop consuming the from channel if the to channel closes. See also pipeline, pipeline-blocking.</p></div></div></div><div class="public anchor" id="var-pipeline-blocking"><h3>pipeline-blocking</h3><div class="usage"><code>(pipeline-blocking n to xf from)</code><code>(pipeline-blocking n to xf from close?)</code><code>(pipeline-blocking n to xf from close? ex-handler)</code></div><div class="doc"><div class="markdown"><p>Like pipeline, for blocking operations.</p></div></div></div><div class="public anchor" id="var-poll.21"><h3>poll!</h3><div class="usage"><code>(poll! port)</code></div><div class="doc"><div class="markdown"><p>Takes a val from port if it’s possible to do so immediately. Never blocks. Returns value if successful, nil otherwise.</p></div></div></div><div class="public anchor" id="var-promise-chan"><h3>promise-chan</h3><div class="usage"><code>(promise-chan)</code><code>(promise-chan xform)</code><code>(promise-chan xform ex-handler)</code></div><div class="doc"><div class="markdown"><p>Creates a promise channel with an optional transducer, and an optional exception-handler. A promise channel can take exactly one value that consumers will receive. Once full, puts complete but val is dropped (no transfer). Consumers will block until either a value is placed in the channel or the channel is closed. See chan for the semantics of xform and ex-handler.</p></div></div></div><div class="public anchor" id="var-pub"><h3>pub</h3><div class="usage"><code>(pub ch topic-fn)</code><code>(pub ch topic-fn buf-fn)</code></div><div class="doc"><div class="markdown"><p>Creates and returns a pub(lication) of the supplied channel, partitioned into topics by the topic-fn. topic-fn will be applied to each value on the channel and the result will determine the ‘topic’ on which that value will be put. Channels can be subscribed to receive copies of topics using ‘sub’, and unsubscribed using ‘unsub’. Each topic will be handled by an internal mult on a dedicated channel. By default these internal channels are unbuffered, but a buf-fn can be supplied which, given a topic, creates a buffer with desired properties.</p>
<p>Each item is distributed to all subs in parallel and synchronously, i.e. each sub must accept before the next item is distributed. Use buffering/windowing to prevent slow subs from holding up the pub.</p>
<p>Items received when there are no matching subs get dropped.</p>
<p>Note that if buf-fns are used then each topic is handled asynchronously, i.e. if a channel is subscribed to more than one topic it should not expect them to be interleaved identically with the source.</p></div></div></div><div class="public anchor" id="var-receive"><h3>receive</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Alias for <code>core.async/&lt;!</code> - takes a val from port.</p>
<pre><code>(receive port)
</code></pre>
<p>Must be called inside a <code>(spawn ...)</code> block. Will return <code>nil</code> if closed. Will park if nothing is available.</p></div></div></div><div class="public anchor" id="var-receive.21"><h3>receive!</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Alias for <code>core.async/take!</code>.</p>
<pre><code>(receive! port fn1)
(receive! port fn1 on-caller?)
</code></pre>
<p>Asynchronously takes a val from <code>port</code>, passing to <code>fn1</code>. Will pass <code>nil</code> if closed. If <code>on-caller?</code> (default <code>true</code>) is <code>true</code>, and value is immediately available, will call <code>fn1</code> on calling thread.</p></div></div></div><div class="public anchor" id="var-receive-blocking"><h3>receive-blocking</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Alias for <code>core.async/&lt;!!</code> - takes a val from port.</p>
<pre><code>(receive-blocking port)
</code></pre>
<p>Will return <code>nil</code> if closed. Will block if nothing is available.</p></div></div></div><div class="public anchor" id="var-reduce"><h3>reduce</h3><div class="usage"><code>(reduce f init ch)</code></div><div class="doc"><div class="markdown"><p>f should be a function of 2 arguments. Returns a channel containing the single result of applying f to init and the first item from the channel, then applying f to that result and the 2nd item, etc. If the channel closes without yielding items, returns init and f is not called. ch must close before reduce produces a result.</p></div></div></div><div class="public anchor" id="var-select"><h3>select</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Alias for <code>core.async/alts!</code> - completes at most one of several channel operations.</p>
<pre><code>(select ports &amp; {:as opts})
</code></pre>
<p>Must be called inside a <code>(spawn ...)</code> block. ports is a vector of channel endpoints, which can be either a channel to take from or a vector of <code>[channel-to-send-to val-to-send]</code>, in any combination. Takes will be made as if by <code>(receive ...)</code>, and puts will be made as if by <code>(send ...)</code>.</p></div></div></div><div class="public anchor" id="var-select-blocking"><h3>select-blocking</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Alias for <code>core.async/alts!!</code>.</p>
<pre><code>(select-blocking ports &amp; {:as opts})
</code></pre>
<p>Like <code>select</code>, except takes will be made as if by <code>(receive-blocking ...)</code>, and puts will be made as if by <code>(send-blocking ...)</code>. A call will block until completed; not intended for use in <code>(spawn ...)</code> blocks.</p></div></div></div><div class="public anchor" id="var-send"><h3>send</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Alias for <code>core.async/&gt;!</code> - puts a val into port.</p>
<pre><code>(send val port)
</code></pre>
<p><code>nil</code> values are not allowed. Must be called inside a <code>(spawn ...)</code> block. Will park if no buffer space is available. Returns <code>true</code> unless port is already closed.</p></div></div></div><div class="public anchor" id="var-send.21"><h3>send!</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Alias for <code>core.async/put!</code>.</p>
<pre><code>(send! port val)
(send! port val fn1)
(send! port val fn1 on-caller?)
</code></pre>
<p>Asynchronously puts a val into <code>port</code>, calling <code>fn1</code> (if supplied) when complete, passing <code>false</code> iff <code>port</code> is already closed. <code>nil</code> values are not allowed. If <code>on-caller?</code> (default <code>true</code>) is <code>true</code>, and the put is immediately accepted, will call <code>fn1</code> on calling thread. Returns <code>true</code> unless port is already closed.</p></div></div></div><div class="public anchor" id="var-send-blocking"><h3>send-blocking</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Alias for <code>core.async/&gt;!!</code> - puts a val into port.</p>
<pre><code>(send-blocking val port)
</code></pre>
<p><code>nil</code> values are not allowed. Will block if no buffer space is available. Returns <code>true</code> unless port is already closed.</p></div></div></div><div class="public anchor" id="var-sliding-buffer"><h3>sliding-buffer</h3><div class="usage"><code>(sliding-buffer n)</code></div><div class="doc"><div class="markdown"><p>Returns a buffer of size n. When full, puts will complete, and be buffered, but oldest elements in buffer will be dropped (not transferred).</p></div></div></div><div class="public anchor" id="var-solo-mode"><h3>solo-mode</h3><div class="usage"><code>(solo-mode mix mode)</code></div><div class="doc"><div class="markdown"><p>Sets the solo mode of the mix. mode must be one of :mute or :pause</p></div></div></div><div class="public anchor" id="var-spawn"><h3>spawn</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Alias for <code>core.async/go</code> (macro) - asynchronously executes the body, returning immediately to the calling thread.</p>
<pre><code>(spawn &amp; body)
</code></pre>
<p>Additionally, any visible calls to <code>send</code>, <code>receive</code>, and <code>select*</code> channel operations within the body will block (if necessary) by ‘parking’ the calling thread rather than tying up an OS thread. Upon completion of the operation, the body will be resumed.</p></div></div></div><div class="public anchor" id="var-spawn-loop"><h3>spawn-loop</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Alias for <code>core.async/go-loop</code> (macro).</p>
<pre><code>(spawn-loop bindings &amp; body)
</code></pre>
<p>Like <code>(spawn (loop ...))</code></p></div></div></div><div class="public anchor" id="var-split"><h3>split</h3><div class="usage"><code>(split p ch)</code><code>(split p ch t-buf-or-n f-buf-or-n)</code></div><div class="doc"><div class="markdown"><p>Takes a predicate and a source channel and returns a vector of two channels, the first of which will contain the values for which the predicate returned true, the second those for which it returned false.</p>
<p>The out channels will be unbuffered by default, or two buf-or-ns can be supplied. The channels will close after the source channel has closed.</p></div></div></div><div class="public anchor" id="var-sub"><h3>sub</h3><div class="usage"><code>(sub p topic ch)</code><code>(sub p topic ch close?)</code></div><div class="doc"><div class="markdown"><p>Subscribes a channel to a topic of a pub.</p>
<p>By default the channel will be closed when the source closes, but can be determined by the close? parameter.</p></div></div></div><div class="public anchor" id="var-take"><h3>take</h3><div class="usage"><code>(take n ch)</code><code>(take n ch buf-or-n)</code></div><div class="doc"><div class="markdown"><p>Returns a channel that will return, at most, n items from ch. After n items  have been returned, or ch has been closed, the return channel will close.</p>
<p>The output channel is unbuffered by default, unless buf-or-n is given.</p></div></div></div><div class="public anchor" id="var-tap"><h3>tap</h3><div class="usage"><code>(tap mult ch)</code><code>(tap mult ch close?)</code></div><div class="doc"><div class="markdown"><p>Copies the mult source onto the supplied channel.</p>
<p>By default the channel will be closed when the source closes, but can be determined by the close? parameter.</p></div></div></div><div class="public anchor" id="var-thread"><h3>thread</h3><h4 class="type">macro</h4><div class="usage"><code>(thread &amp; body)</code></div><div class="doc"><div class="markdown"><p>Executes the body in another thread, returning immediately to the calling thread. Returns a channel which will receive the result of the body when completed, then close.</p></div></div></div><div class="public anchor" id="var-thread-call"><h3>thread-call</h3><div class="usage"><code>(thread-call f)</code></div><div class="doc"><div class="markdown"><p>Executes f in another thread, returning immediately to the calling thread. Returns a channel which will receive the result of calling f when completed, then close.</p></div></div></div><div class="public anchor" id="var-timeout"><h3>timeout</h3><div class="usage"><code>(timeout msecs)</code></div><div class="doc"><div class="markdown"><p>Returns a channel that will close after msecs</p></div></div></div><div class="public anchor" id="var-to-chan"><h3>to-chan</h3><div class="usage"><code>(to-chan coll)</code></div><div class="doc"><div class="markdown"><p>Creates and returns a channel which contains the contents of coll, closing when exhausted.</p></div></div></div><div class="public anchor" id="var-toggle"><h3>toggle</h3><div class="usage"><code>(toggle mix state-map)</code></div><div class="doc"><div class="markdown"><p>Atomically sets the state(s) of one or more channels in a mix. The state map is a map of channels -&gt; channel-state-map. A channel-state-map is a map of attrs -&gt; boolean, where attr is one or more of :mute, :pause or :solo. Any states supplied are merged with the current state.</p>
<p>Note that channels can be added to a mix via toggle, which can be used to add channels in a particular (e.g. paused) state.</p></div></div></div><div class="public anchor" id="var-unblocking-buffer.3F"><h3>unblocking-buffer?</h3><div class="usage"><code>(unblocking-buffer? buff)</code></div><div class="doc"><div class="markdown"><p>Returns true if a channel created with buff will never block. That is to say, puts into this buffer will never cause the buffer to be full. </p></div></div></div><div class="public anchor" id="var-unique"><h3>unique</h3><h4 class="deprecated">deprecated in 0.1.319.0-6b1aca-alpha</h4><div class="usage"><code>(unique ch)</code><code>(unique ch buf-or-n)</code></div><div class="doc"><div class="markdown"><p>Deprecated - this function will be removed. Use transducer instead</p></div></div></div><div class="public anchor" id="var-unmix"><h3>unmix</h3><div class="usage"><code>(unmix mix ch)</code></div><div class="doc"><div class="markdown"><p>Removes ch as an input to the mix</p></div></div></div><div class="public anchor" id="var-unmix-all"><h3>unmix-all</h3><div class="usage"><code>(unmix-all mix)</code></div><div class="doc"><div class="markdown"><p>removes all inputs from the mix</p></div></div></div><div class="public anchor" id="var-unsub"><h3>unsub</h3><div class="usage"><code>(unsub p topic ch)</code></div><div class="doc"><div class="markdown"><p>Unsubscribes a channel from a topic of a pub</p></div></div></div><div class="public anchor" id="var-unsub-all"><h3>unsub-all</h3><div class="usage"><code>(unsub-all p)</code><code>(unsub-all p topic)</code></div><div class="doc"><div class="markdown"><p>Unsubscribes all channels from a pub, or a topic of a pub</p></div></div></div><div class="public anchor" id="var-untap"><h3>untap</h3><div class="usage"><code>(untap mult ch)</code></div><div class="doc"><div class="markdown"><p>Disconnects a target channel from a mult</p></div></div></div><div class="public anchor" id="var-untap-all"><h3>untap-all</h3><div class="usage"><code>(untap-all mult)</code></div><div class="doc"><div class="markdown"><p>Disconnects all target channels from a mult</p></div></div></div></div></body></html>